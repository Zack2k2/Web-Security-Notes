<h3><u>
1.1 Finding Reflected vulnerability
</u></h3>

Most reliable way to find a XSS vulnerability is to manually enter submit input to every entry point that is identified through spider-ing the web application.

1. Submit mundane data to every input and check for any reflection.
2. identify all location where this string is reflected in the application response.
3. For each of those places where the response appears try to recognize and identify the context with in which it exist.
4. submit modified data that would be processed; introduce arbitrary script in to responds.
5. If the reflected data is blocked then try, executing your script with by circumventing the application defense  filters.

<h3><u><i>Hack Steps:</i></u></h3>

<ol>
	<li>Choose an arbitrary string that contains alphanumeric characters like <b>`myxssstr1234`</b> because they are so mundane they will not trigger any XSS filter and just pass 
	through and now submit it in every input parameter. 
	</li>
	
	<li>
	Monitor the Application for any reflection from the submitted text string. 
	</li>
	
	<li>
	Note all the <b>GET</b> and <b>POST</b> requests 
	need to be test. You should include every parameter
	within both URL query string and the message body. POST request can be trigger XSS vulnerability. 
	</li>
	<li>
	in case if xss is found on POST try using burp change method to find if it can happen on the GET request.
	</li>
	<li>
	test every instance in which the application process the contents of HTTP request header. 
	A common XSS vulnerability arises in error messages, items such Referer and User-Agent headers are copied to to message contents of error page.
	</li>
</ol>

<b>examples</b>
Zohaib keep in mind that context in which the reflected 
string appers like this with in tag attribute.

 ```
 <input type="text" name="address1" value="myxssstr1234">
 ```

injection like ```"<script>alert(1)</script>``` 
or ``` "onfocus=alert(1)```


or in a javascript string,
``` <script>var a = 'myxssstr1234'; var b = 123; ... </script>```

another one in which an attribute containing URL.

```<a href="myxssstr1234">Click here </a>```

xss injection here is 
```
javascript:alert(1)
``` 
and 
 ```
 #"onclick="javascript:alert(1)
```

<u>two solution</u>
1. javascript.alert(1)
2. #"onclick="javascript.alert(1)

<h3>hack tips:</h3>

1. Review and analyze the html to identify the location(s) where your unique input string is reflected.

2. if the unique string is reflected more then once then analyze each of those occurrences individually for the xss vulnerability.

3. Determine, from the location with in the HTML of use controllable string, how you need to modify the input to cause a arbitrary script.

4. If the exploit input is reflected in to web pages is unmodified then the application is vulnerable. Double check that your payload is running in the web browser. like proof of concept to display the alert box for document cookie. 


<h3><b><u>1.2 Probing defensive filters</u></b></h3>

If the payload exploit is modified in some way or another in the application and does not execute the payload; zohaib do not give now! the next task is to determine what is happening on the server side. this involves doing reconisense of factors that might be effecting the input of the payload, there are three possibilities:
1. (signature based filters)The application or WAF, xss attack signature.
2. application has accepted but has performed some kind a sanitized or encoding on the attack string.
3. Application has truncated your attack to string to fixed maximum length.

<h4>1.2.1 beating signature based filters<h4>

remove different part of payload string to determine which sub-strings are being blocked.

1. try inserting script in event handlers.
2. insert null bytes with in tag names, 
```
<i[%00]mg onerror=alert(1) src=a>
```

<h3>How to find and test for reflected XSS vulnerabilities</h3>
<h3>(According to port swigger)</h3>

1. <b>Test every entry point.</b>
   Test separately every entry point for data within the Application HTTP requests. This include parameters or other
   data with in URL.
2. <b>Submit random random values to every entry point.</b> 
	For each entry point submit a random unique values, 
	they must have alphanumeric value such that they can
	survive all input validations and xss filters. it should be 
	short but long enough to not make any accidental matches. 

3. <b>determine the reflection context</b>
   Determine the context of reflection with in which the 
   XSS string has occured.

4. <b>Test the candidate payload</b>
	Based on the context of the reflection, test an initial payload. The easiest way payloads is to send HTTP request to **burp repeater**
	modify the request to insert a payload , issue the request, then 
	review the respond to see if the payload worked. 
	first send normal string with repeater to review the html pages where the string is reflected and burp will highlight the 
	reflection.


5. <b>Test alternative payloads</b>
   If the candidate XSS payload was modified then you need to test alternative payload that might work.















